'use strict';

const {
  forEachDefinition, forEachMemberRecursively, getArtifactDatabaseNameOf, getElementDatabaseNameOf, forEachMember,
} = require('../../model/csnUtils');
/**
 * Attach @cds.persistence.name to all artifacts and "things".
 * We could also do it more selectively like we do in forRelationalDb, but: Why? Space maybe?
 * @param {CSN.Model} csn
 * @param {CSN.Options} options
 * @param {object} csnUtils
 */
function attachPersistenceName( csn, options, csnUtils ) {
  const { addStringAnnotationTo } = csnUtils;

  forEachDefinition(csn, (artifact, artifactName) => {
    if (artifact.kind === 'entity') {
      addStringAnnotationTo('@cds.persistence.name', getArtifactDatabaseNameOf(artifactName, options.sqlMapping, csn, options.sqlDialect), artifact);

      forEachMemberRecursively(artifact, (member, memberName) => addStringAnnotationTo('@cds.persistence.name', getElementDatabaseNameOf(memberName, options.sqlMapping, options.sqlDialect), member), [ 'definitions', artifactName ]);
    }
  });
}

const artifactPropertiesToRemove = [ 'includes' ];
const memberPropertiesToRemove = [ 'localized', 'enum', 'keys' ];

/**
 * Remove definitions from the CSN:
 * - types
 * - aspects
 *
 * Remove properties from artifacts:
 * - includes
 * - localized
 * @param {CSN.Model} csn
 * @todo Callback-like architecture and merge with persistence name?
 */
function removeDefinitionsAndProperties( csn ) {
  forEachDefinition(csn, (artifact, artifactName) => {
    if (artifact.kind === 'aspect' || artifact.kind === 'type') {
      delete csn.definitions[artifactName];
    }
    else {
      if (artifact['@cds.persistence.skip'] === 'if-unused')
        artifact['@cds.persistence.skip'] = false;
      for (const prop of artifactPropertiesToRemove)
        delete artifact[prop];

      forEachMember(artifact, (member) => {
        for (const prop of memberPropertiesToRemove)
          delete member[prop];
      });
    }
  });
}

module.exports = {
  attachPersistenceName,
  removeDefinitionsAndProperties,
};
