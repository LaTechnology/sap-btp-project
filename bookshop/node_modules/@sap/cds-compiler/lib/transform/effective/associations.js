'use strict';

const { setProp } = require('../../base/model');
const flattening = require('../db/flattening');
const {
  applyTransformations, forEachDefinition, forEachMemberRecursively, implicitAs, cloneCsnNonDict,
} = require('../../model/csnUtils');
const associations = require('../db/associations');
const backlinks = require('../db/backlinks');


/**
 * Turn managed associations into unmanaged ones by
 * - unfolding the .keys
 * - creating the foreign keys in .elements
 * - adding a corresponding on-condition
 * @param {CSN.Model} csn Input CSN - will not be transformed
 * @param {CSN.Options} options
 * @param {object} csnUtils
 * @param {object} messageFunctions
 * @param {Function} messageFunctions.error
 * @param {Function} messageFunctions.warning
 * @todo Remove .keys afterwards
 * @todo Add created foreign keys into .columns in case of a query?
 * @returns {CSN.Model}
 */
function turnAssociationsIntoUnmanaged( csn, options, csnUtils, { error, warning } ) {
  // TODO: Do we really need this?
  forEachDefinition(csn, (artifact, artifactName) => {
    setProp(artifact, '$path', [ 'definitions', artifactName ]);
    forEachMemberRecursively(artifact, (member, memberName, prop, path) => {
      setProp(member, '$path', path);
    }, [ 'definitions', artifactName ]);
  });
  // Flatten out the fks and create the corresponding elements
  flattening.handleManagedAssociationsAndCreateForeignKeys(csn, options, error, warning, '_', true, csnUtils, { allowArtifact: a => a.kind === 'entity' });

  // Add the foreign keys also to the columns if the association itself was explicitly selected
  // TODO: Extend the expansion to also expand managed to their foreign
  // TODO: Remember where in .elements we had associations and do it then?
  applyTransformations(csn, {
    columns: (parent, prop, columns) => {
      const newColumns = [];
      for (const col of columns) {
        newColumns.push(col);
        const element = csnUtils.getElement(col);
        if (element && element.keys)
          element.keys.forEach(fk => addForeignKeyToColumns(fk, newColumns, col, options));
      }
      parent.columns = newColumns;
    },
  }, [], { allowArtifact: artifact => artifact.kind === 'entity' });

  forEachDefinition(csn, associations.getFKAccessFinalizer(csn, csnUtils, '_'));
  // Calculate the on-conditions from the .keys -
  associations.attachOnConditions(csn, csnUtils, '_');

  return csn;
}

/**
 * FKs need to be added to the .columns
 * @todo stolen from lib/transform/db/views.js
 * @todo Can we maybe do this during expansion already?
 * @param {object} foreignKey
 * @param {object[]} columns
 * @param {CSN.Column} associationColumn
 * @param {CSN.Options} options
 */
function addForeignKeyToColumns( foreignKey, columns, associationColumn, options ) {
  const ref = cloneCsnNonDict(associationColumn.ref, options);
  ref[ref.length - 1] = [ implicitAs(ref) ].concat(foreignKey.as || foreignKey.ref).join('_');
  const result = {
    ref,
  };
  if (associationColumn.as) {
    const columnName = `${associationColumn.as}_${foreignKey.as || implicitAs(foreignKey.ref)}`;
    result.as = columnName;
  }

  if (associationColumn.key)
    result.key = true;

  columns.push(result);
}

/**
 * Translate $self backlinks to "normal" on-conditions
 * @param {CSN.Model} csn Input CSN - will not be transformed
 * @param {CSN.Options} options
 * @param {object} csnUtils
 * @param {object} messageFunctions
 */
function transformBacklinks( csn, options, csnUtils, messageFunctions ) {
  forEachDefinition(csn, backlinks.getBacklinkTransformer(csnUtils, messageFunctions, options, '_', true));
}

module.exports = {
  managedToUnmanaged: turnAssociationsIntoUnmanaged,
  transformBacklinks,
};
